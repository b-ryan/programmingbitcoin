(ns programming-bitcoin.bitcoin-curve
  (:require [clojure.math.numeric-tower :refer [expt]]
            [programming-bitcoin.finite-fields :as ff]
            [programming-bitcoin.elliptic-curves :as ec]))

(def ^:private prime
  (-> (.pow (biginteger 2) (biginteger 256))
      (.subtract (.pow (biginteger 2) (biginteger 32)))
      (.subtract (biginteger 977))))

(defn e
  [number]
  (ff/e number prime))

(defn p
  [x y]
  (ec/p (if (integer? x) (e (biginteger x)) x)
        (if (integer? y) (e (biginteger y)) y)
        (e (biginteger 0))
        (e (biginteger 7))))

(def ^{:doc "Generator point of the Bitcoin curve."}
     G
  (point
   0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
   0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
  ))

(def
  ^{:doc
    "The order of the group generated by G.

  Ie. the number of points in the group. G * n = point at infinity."}
  N
  (biginteger
   0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141))

#_(clojure.pprint/pprint (ec/scalar-mul G N))

(defrecord Signature [r s])

(defn valid-signature?
  [point ^BigInteger z {:keys [^BigInteger r ^BigInteger s] :as signature}]
  (let [s-inv (.modPow s (.subtract N (biginteger 2)) N)
        u (.mod (.multiply z s-inv) N)
        v (.mod (.multiply r s-inv) N)
        total (ec/add (ec/scalar-mul G u) (ec/scalar-mul point v))]
    (= (:number (:x total)) r)))

#_(let [point
        (p
         0x887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c
         0x61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34)
        z (biginteger
           0xec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60)
        r (biginteger
           0xac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395)
        s (biginteger
           0x68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4)
        sig (->Signature r s)]
    (valid-signature? point z sig))
