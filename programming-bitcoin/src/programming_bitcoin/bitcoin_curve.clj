(ns programming-bitcoin.bitcoin-curve
  (:require [clojure.math.numeric-tower :refer [expt]]
            [programming-bitcoin.finite-fields :as ff]
            [programming-bitcoin.elliptic-curves :as ec]
            [programming-bitcoin.primitives :refer [biginteger?]])
  (:import (java.security SecureRandom)))

(def ^:private ^BigInteger prime
  (-> (.pow (biginteger 2) (biginteger 256))
      (.subtract (.pow (biginteger 2) (biginteger 32)))
      (.subtract (biginteger 977))))

(defn e [number] (ff/e number prime))

(defn p
  [x y]
  (ec/p (if (integer? x) (e (biginteger x)) x)
        (if (integer? y) (e (biginteger y)) y)
        (e (biginteger 0))
        (e (biginteger 7))))

(def ^{:doc "Generator point of the Bitcoin curve."} G
  (p 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
     0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8))

(def
  ^{:doc
    "The order of the group generated by G.

  Ie. the number of points in the group. G * n = point at infinity."}
  ^BigInteger N
  (biginteger
   0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141))

#_(clojure.pprint/pprint (ec/scalar-mul G N))

(defrecord Signature [r s])

(defn valid-signature?
  [point ^BigInteger z {:keys [^BigInteger r ^BigInteger s] :as signature}]
  (let [s-inv (.modPow s (.subtract N (biginteger 2)) N)
        u (.mod (.multiply z s-inv) N)
        v (.mod (.multiply r s-inv) N)
        total (ec/add (ec/scalar-mul G u) (ec/scalar-mul point v))]
    (= (:number (:x total)) r)))

#_(let [point
        (p 0x887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c
           0x61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34)
        z (biginteger
           0xec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60)
        r (biginteger
           0xac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395)
        s (biginteger
           0x68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4)
        sig (->Signature r s)]
    (valid-signature? point z sig))

(defrecord PrivateKey [secret point])

(defn secret->private-key
  [secret]
  {:pre [(integer? secret)]}
  (->PrivateKey (biginteger secret) (ec/scalar-mul G secret)))

(defn rand-biginteger
  ^BigInteger [max-val]
  {:pre [(biginteger? max-val)] :post [(biginteger? %)]}
  ;; TODO not sure if this mod is secure / the right way to do this. Generally,
  ;; this randomness was put together quickly, questionable (at best) for
  ;; production use.
  ;; TODO deterministic k generation (RFC 6979)
  (.mod (BigInteger. 256 (SecureRandom.)) max-val))

(defn sign
  [{:keys [^BigInteger secret point] :as private-key} z]
  {:pre [(integer? z)]}
  (let [z (biginteger z)
        k (rand-biginteger N)
        r (:number (:x (ec/scalar-mul G k)))
        k-inv (.modPow k (.subtract N (biginteger 2)) N)
        s (-> (.multiply secret r)
              (.add z)
              (.multiply k-inv)
              (.mod N))]
    (->Signature r (if (> s (.divide N (biginteger 2))) (.subtract N s) s))))
